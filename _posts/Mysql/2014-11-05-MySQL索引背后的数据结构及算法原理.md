---
layout: post
title: Mysql索引背后的数据结构及算法原理
category: Mysql
tags: Mysql
---

### MyISAM索引B+树
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址

![mysql-index-mysaim B+](/public/img/mysql-index-mysaim B+.png)


### Innode索引B+树

<http://blog.codinglabs.org/articles/theory-of-mysql-index.html>

InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

![mysql-innode-B+](/public/img/mysql-innode-B+.png)

可以看到叶节点包含了完整的数据记录，这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。


第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如

![mysql-innode-B+ Second](/public/img/mysql-innode-B+ Second.png)





### 每个Page内部的结构

转 <http://www.cnblogs.com/vinchen/archive/2012/09/10/2679478.html>


![mysql-index-page struct.jpg](/public/img/mysql-index-page struct.jpg)

1. 页头（Page Header）：记录页面的控制信息，共占150字节，包括页的左右兄弟页面指针、页面空间使用情况等，页头的详细说明会在下一篇中描述。

2. 最小虚记录、最大虚记录：两个固定位置存储的虚记录，本身并不存储数据。最小虚记录比任何记录都小，而最大虚记录比任何记录都大。

3. 记录堆（record heap）：指上图的橙黄色部分。表示页面已分配的记录空间，也是索引数据的真正存储区域。记录堆分为两种，即有效记录和已删除记录。有效记录就是索引正常使用的记录，而已删除记录表示索引已经删除，不在使用的记录，如上图的深蓝色部分。随着记录的更新和删除越来越频繁，记录堆中已删除记录将会越多，即会出现越来越多的空洞（碎片）。这些已删除记录连接起来，就会成为页面的自由空间链表。

4. 未分配空间：指页面未使用的存储空间，随着页面不断使用，未分配空间将会越来越小。当新插入一条记录时，首先尝试从自由空间链表中获得合适的存储位置（空间足够），如果没有满足的，就会在未分配空间中申请。

5. slot区：slot是一些页面有效记录的指针，每个slot占两个字节，存储了记录相对页面首地址的偏移。如果页面有n条有效记录，那么slot的数量就在n/8+2~n/4+2之间。下一节详细介绍slot区，它是记录页面有序和二分查找的关键。

6. 页尾（Page Tailer）：页面最后部分，占8个字节，主要存储页面的校验信息。

### 数据页内的数据是按索引键有序的，如何保证这种有序性呢？

#### InnodeDB
![mysql-index-page record link.jpg](/public/img/mysql-index-page record link.jpg)

Record按照索引大小用链表串起来，然后每隔几个有一个Slot指针

###### 如何查询？

如果在页面中查询记录r1。首先通过二分查找定位Slot号X，满足

rec[X-1]< r1 <= rec[X]

接着就是遍历这条Slot支链，找到真正记录。但支链的搜索只能一一遍历，不能使用二分查找。

##### 如何插入？

首先通过查询的方式确定插入的Slot支链和插入位置，在自由空间链表或未分配空间中获得空间并写记录内容，slot支链高度加1，同时维护好原链表的关系。

插入记录后，如果Slot支链高度超过8，那么就将该支链拆分为两个子链，同时多申请一个slot（平移此slot及其后面的空间）。





### 局部性原理与磁盘预读

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用。

程序运行期间所需要的数据通常比较集中。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
